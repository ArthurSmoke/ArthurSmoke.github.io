[{"categories":null,"content":"Pytest 最近在学习实践自动化相关的知识，最终选用 pytest 来组织测试用例，本文是 pytest 学习笔记的第一篇。 Fixture 是 pytest 中的一个基本概念，可以简单理解为在测试用例前需要执行的内容，我用来初始化环境、准备数据等工作。 ","date":"2019-03-16","objectID":"/pytest-fixture-note/:1:0","tags":null,"title":"Pytest Fixture Note","uri":"/pytest-fixture-note/"},{"categories":null,"content":"Fixture 最近在学习实践自动化相关的知识，最终选用 pytest 来组织测试用例，本文是 pytest 学习笔记的第一篇。 Fixture 是 pytest 中的一个基本概念，可以简单理解为在测试用例前需要执行的内容，我用来初始化环境、准备数据等工作。 ","date":"2019-03-16","objectID":"/pytest-fixture-note/:2:0","tags":null,"title":"Pytest Fixture Note","uri":"/pytest-fixture-note/"},{"categories":null,"content":"Fixture 在被当做 fixture 的函数前面加上 @pytest.fixture来定义一个 Fixture @pytest.fixture() def before(): print('\\nbefore each test') Scope function：每个 test 都运行，默认是 function 的 scope class：每个 class 的所有 test 只运行一次 module：每个 module 的所有 test 只运行一次 session：每个 session 只运行一次 @pytest.fixture(scope=\"module\") def smtp(): smtp = smtplib.SMTP(\"smtp.gmail.com\", 587, timeout=5) yield smtp #yield下面是teardown内容 smtp.close() def test_ehlo(smtp): #fixture的function名称，可以直接作为参数，传给需要使用它的测试样例。 在使用时，smtp并非前面定义的function，而是function的返回值，即smtplib.SMTP response, msg = smtp.ehlo() assert response == 250 assert b\"smtp.gmail.com\" in msg conftest.py conftest.py是 pytest 的默认配置文件，可以在其中放公用的 fixture 或 plugin。 tests ├── conftest.py ├── test_a.py ├── test_b.py └── sub ├── __init__.py ├── conftest.py ├── test_c.py └── test_d.py conftest.py遵守就近原则，会优先使用层级最近的 conftest 中定义的 Fixture。同时外层的测试用例 a,b 不能使用内层conftest.py中定义的 fixture ","date":"2019-03-16","objectID":"/pytest-fixture-note/:2:1","tags":null,"title":"Pytest Fixture Note","uri":"/pytest-fixture-note/"},{"categories":null,"content":"Use Fixture 1. 当做参数直接调用 @pytest.fixture(scope=\"module\") def smtp(): smtp = smtplib.SMTP(\"smtp.gmail.com\", 587, timeout=5) yield smtp smtp.close() def test_ehlo(smtp): response, msg = smtp.ehlo() assert response == 250 assert b\"smtp.gmail.com\" in msg fixture 的 function 名称，可以直接作为参数，传给需要使用它的测试样例。 在使用时，smtp并非前面定义的 function，而是 function 的返回值，即smtplib.SMTP 2. 在函数前用 Fixture Decorator 调用 @pytest.mark.usefixtures(\"before\") def test_1(): print('test_1()') class Test1: @pytest.mark.usefixtures(\"before\") def test_3(self): print('test_1()') @pytest.mark.usefixtures(\"before\") def test_4(self): print('test_2()') @pytest.mark.usefixtures(\"before\") class Test2: def test_5(self): print('test_1()') def test_6(self): print('test_2()') 3. 用 Autouse 调用 Fixture fixture decorator 一个 optional 的参数是autouse, 默认设置为 False。 当默认为 False，就可以选择用上面两种方式来试用 fixture。 当设置为 True 时，在一个 session 内的所有的 test 都会自动调用这个 fixture。 @pytest.fixture(autouse=True) def before(): print('\\nbefore each test') ","date":"2019-03-16","objectID":"/pytest-fixture-note/:2:2","tags":null,"title":"Pytest Fixture Note","uri":"/pytest-fixture-note/"},{"categories":null,"content":"Finallizer @pytest.fixture() def smtp(request): smtp = smtplib.SMTP(\"smtp.gmail.com\") def fin(): #释放函数 print (\"teardown smtp\") smtp.close() request.addfinalizer(fin) #测试完成后调用 return smtp 通过addfinallizer()注册释放函数 ","date":"2019-03-16","objectID":"/pytest-fixture-note/:2:3","tags":null,"title":"Pytest Fixture Note","uri":"/pytest-fixture-note/"},{"categories":null,"content":"Parametrizing fixture 可以通过参数化来循环使用预设的参数 1. params @pytest.fixture(params=[\"smtp.gmail.com\", \"mail.python.org\"]) def smtp(request): smtp = smtplib.SMTP(request.param, 587, timeout=5) yield smtp print (\"finalizing %s\" % smtp) smtp.close() 在 @pytest.fixture中，指定参数params，就可以利用特殊对象（request）来引用request.param。 使用以上带参数的 smtp 的测试样例，都会被执行两次。 2. @pytest.mark.parametrize def add(a, b): return a + b @pytest.mark.parametrize(\"test_input, expected\", [ ([1, 1], 2), ([2, 2], 4), ([0, 1], 1), ]) def test_add(test_input, expected): assert expected == add(test_input[0], test_input[1]) ","date":"2019-03-16","objectID":"/pytest-fixture-note/:2:4","tags":null,"title":"Pytest Fixture Note","uri":"/pytest-fixture-note/"},{"categories":null,"content":"Build-in Fixture pytest --fixtures可以列出所有可用的 fixture，包括内置的、插件中的、以及当前项目定义的。 capsys capsys可以捕捉测试 function 的标准输出 def test_print(capsys): print('hello') out, err = capsys.readouterr() assert 'hello' == out tmpdir tmpdir则可以自动创建临时文件夹 def test_path(tmpdir): from py._path.local import LocalPath assert isinstance(tmpdir, LocalPath) from os.path import isdir assert isdir(str(tmpdir)) ","date":"2019-03-16","objectID":"/pytest-fixture-note/:2:5","tags":null,"title":"Pytest Fixture Note","uri":"/pytest-fixture-note/"},{"categories":null,"content":"参考 《Pytest 中的 Fixture》 《Pytest Fixture》 《pytest fixtures: explicit, modular, scalable》 ","date":"2019-03-16","objectID":"/pytest-fixture-note/:2:6","tags":null,"title":"Pytest Fixture Note","uri":"/pytest-fixture-note/"},{"categories":null,"content":"Hugo, the world’s fastest framework for building websites","date":"2019-02-28","objectID":"/about/","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"马甲 Arthur Feng , 洋葱爱生活 ","date":"2019-02-28","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"爱好 宅，动漫，电影，游戏，美食，书 ","date":"2019-02-28","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"工作 2010-2015：武汉惠普企业服务交付有限公司：专职测试 2015-2018：杭州九言科技股份有限公司：业务测试负责人 2018-2019：杭州兑吧网络科技有限公司：天天趣闻测试负责人 2019-Now： 杭州印鸽科技有限公司：测试 ","date":"2019-02-28","objectID":"/about/:3:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"我自己眼中的我 80 后，奔三的 吃货一枚！ 每个故事中都有一个胖子，我就是那个胖子！ 强迫症患者，人人、 微博、GR 未读数大于 10 我会死！ 少壮不努力，长大做挨踢！ 学习 Python 中，宅男要拯救世界！ 隐藏在眼镜后的小眼睛时常闪烁着智慧的光芒！ 爱读书，自诩为 2B 的文艺青年！ 部落血精灵牧师，For The Horde！ Cler，冰天雪地全身赤裸一丝不挂五体投地跪求种子！ 艾未未债主，没被请去喝过茶！ 单身，求御姐、萝莉、傲娇、女王拯救！ ","date":"2019-02-28","objectID":"/about/:4:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Wishlist ","date":"2019-02-28","objectID":"/about/:5:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"2019 换工作 考驾照 完成装修 买保险 脱单 ","date":"2019-02-28","objectID":"/about/:5:1","tags":null,"title":"About","uri":"/about/"}]